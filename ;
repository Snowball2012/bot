/* 	Made by Snowball 29.04.2013
 *	Poliz class tree */
#ifndef POLIZ_H
#define POLIZ_H

#include <stdlib.h>
#include <string.h>
#include "lex.h"
#include "id_tables.h"

class PolizElem;
//Poliz list/stack class
class PolizStack;

struct PolizItem 
{
	PolizElem * elem;
	PolizItem * next;
};


class PolizStack
{
public:

private:
	PolizItem * head;
	struct LabelQueue
	{
		Label * label;
		LabelQueue * next;
	};
	LabelQueue * queue;
public:
	PolizStack();
	~PolizStack();
	PolizElem * Pop();
	void Push(PolizElem * new_elem);
	void PushBack(PolizElem * new_elem);
	const PolizItem * GetHead();
	void PutLabel(Label * label); // makes label to point to next poliz elem
};


//Error classes

class NotLabelEx
{
	Lex lexem;
public:	
	NotLabelEx(Lex lex):lexem(Lex::lex_null, NULL, 0)
	{
		lexem = lex;
	}
};

//poliz exeptions

class PolizEx
{
	PolizElem * ex;
public:
	PolizEx(PolizElem * elem) 
	{
		ex = elem;
	}
	virtual void PrintErr() const
	{
		printf("poliz exeption has caught\n");
	}
};

class PolizNotInt
{
public:
	PolizNotInt(PolizElem* elem) {}
};

class PolizNotInt;


class PolizElem
{
public:
	virtual void Evaluate(PolizStack * stack, PolizItem ** cur_cmd) const = 0;
	virtual ~PolizElem() {}
};

class PolizConst:public PolizElem
{
public:
	virtual PolizElem * Clone() const = 0;
	void Evaluate(PolizStack * stack, PolizItem ** cur_cmd) const
	{
		stack->Push(Clone());
		*cur_cmd = (*cur_cmd)->next;
	}
	virtual void Print() const = 0;
};

class PolizFunction:public PolizElem
{
public:
	virtual PolizElem * EvaluateFun(PolizStack * stack) const = 0;
	void Evaluate(PolizStack * stack, PolizItem ** cur_cmd) const
	{
		PolizElem * res = EvaluateFun(stack);
		if(res)
			stack->Push(res);
		*cur_cmd = (*cur_cmd)->next;
	}
};

class PolizOpGo:public PolizElem
{
};

class PolizIf:public PolizElem
{
};

//PolizConst children

class PolizInt:public PolizConst
{
	int val;
public:
	PolizInt(const char * t_value)
	{
		val = atoi(t_value);
	}
	PolizInt(int a)
	{
		val = a;
	}
	virtual PolizElem * Clone() const
	{
		return new PolizInt(val);
	}
	virtual ~PolizInt() {}
	virtual int Get() const
	{
		return val;
	}
	virtual void Print() const
	{
		printf("%i", val);
	}
};

class PolizString:public PolizConst
{
	char * str;
public:
	PolizString(const char * astr)
	{
		str = new char[strlen(astr)+1];
		strcpy(str, astr);
	}
	virtual ~PolizString()
	{
		delete[]str;
	}
	PolizString(const PolizString & pstr)
	{
		str = new char[strlen(pstr.str)+1];
		strcpy(str, pstr.str);
	}
	const char * Get()const
	{
		return str;
	}
	virtual PolizElem * Clone() const
	{
		return new PolizString(*this);
	}
	virtual void Print() const
	{
		printf("%s", str);
	}
};


class PolizLabel:public PolizConst
{
	Label * label;
public:
	PolizLabel(Label * lab)
	{
		label = lab;
	}
	virtual ~PolizLabel() {}
	const PolizItem * Get() const
	{
		return label->GetPoint();
	}
	virtual PolizElem * Clone() const
	{
		return new PolizLabel(label);
	}
	virtual void Print() const
	{
		throw PolizUnprintable(this);
	}
};


//Special const for various arg lists
class PolizArgEnd:public PolizConst
{
public:
	PolizArgEnd() {}
	virtual ~PolizArgEnd() {}
	virtual PolizElem * Clone() const
	{
		return new PolizArgEnd();
	}
	virtual void Print() const
	{
		throw PolizUnprintable(this);
	}
};

//PolizFunction children

class PolizVar:public PolizInt
{
	Variable * var;
public:
	PolizVar(Variable * avar):PolizInt(0)
	{
		var = avar;
	}
	virtual ~PolizVar() {}
	virtual int Get() const
	{
		return var->GetValue();
	}
	virtual PolizElem * Clone() const
	{
		return new PolizVar(var);
	}
	Variable * GetVar() const
	{
		return var;
	}
	virtual void Print() const
	{
		printf("%i", var->GetValue());
	}
};

class PolizSell:public PolizFunction
{
public:
	PolizSell() {}
	virtual ~PolizSell() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * pc = dynamic_cast<PolizInt *>(op1);
		if(!pc)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * pv = dynamic_cast<PolizInt *>(op2);
		if(!pv)
			throw PolizNotInt(op2);
		int count, value;
		count = pc->Get();
		value = pv->Get();
		printf("Sell: %i \tby: %i\n", count, value);
		delete pc;
		delete pv;
		return NULL;
	}
};

class PolizBuy:public PolizFunction
{
public:
	PolizBuy() {}
	virtual ~PolizBuy() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * pc = dynamic_cast<PolizInt *>(op1);
		if(!pc)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * pv = dynamic_cast<PolizInt *>(op2);
		if(!pv)
			throw PolizNotInt(op2);
		int count, value;
		count = pc->Get();
		value = pv->Get();
		printf("Buy: %i \tby: %i\n", count, value);
		delete pc;
		delete pv;
		return NULL;
	}
};

class PolizProd:public PolizFunction
{
public:
	PolizProd() {}
	virtual ~PolizProd() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * pc = dynamic_cast<PolizInt *>(op1);
		if(!pc)
			throw PolizNotInt(op1);
		int count;
		count = pc->Get();
		printf("Prod: %i \n", count);
		delete pc;
		return NULL;
	}
};

class PolizBuild:public PolizFunction
{
public:
	PolizBuild() {}
	virtual ~PolizBuild() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * pc = dynamic_cast<PolizInt *>(op1);
		if(!pc)
			throw PolizNotInt(op1);
		int count;
		count = pc->Get();
		printf("Build: %i \n", count);
		delete pc;
		return NULL;
	}
};

class PolizUpgrade:public PolizFunction
{
	PolizUpgrade() {}
	virtual ~PolizUpgrade() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		printf("Upgraded\n");
		return NULL;
	}
};

class PolizEndturn:public PolizFunction
{
	PolizEndturn() {}
	virtual ~PolizEndturn() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		printf("Turn ended\n");
		return NULL;
	}
};

class PolizFunPlus:public PolizFunction
{
public:
	PolizFunPlus() {}
	virtual ~PolizFunPlus() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1+i2);
	}
};

class PolizFunMinus:public PolizFunction
{
public:
	PolizFunMinus() {}
	virtual ~PolizFunMinus() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1-i2);
	}
};


class PolizFunMinusAlone:public PolizFunction
{
public:
	PolizFunMinusAlone() {}
	virtual ~PolizFunMinusAlone() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		int i1;
		i1 = p1->Get();
		delete p1;
		return new PolizInt(-i1);
	}
};

class PolizFunMul:public PolizFunction
{
public:
	PolizFunMul() {}
	virtual ~PolizFunMul() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1*i2);
	}
};

class PolizFunDiv:public PolizFunction
{
public:
	PolizFunDiv() {}
	virtual ~PolizFunDiv() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i1 = p1->Get();
		i2 = p2->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1/i2);
	}
};

class PolizFunOr:public PolizFunction
{
public:
	PolizFunOr() {}
	virtual ~PolizFunOr() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1||i2);
	}
};

class PolizFunAnd:public PolizFunction
{
public:
	PolizFunAnd() {}
	virtual ~PolizFunAnd() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1&&i2);
	}
};

class PolizFunEq: public PolizFunction 
{
public:
	PolizFunEq() {}
	virtual ~PolizFunEq() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1==i2);
	}
};

class PolizFunLssr: public PolizFunction 
{
public:
	PolizFunLssr() {}
	virtual ~PolizFunLssr() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1<i2);
	}
};

class PolizFunGrtr: public PolizFunction 
{
public:
	PolizFunGrtr() {}
	virtual ~PolizFunGrtr() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1>i2);
	}
};

class PolizFunLeq: public PolizFunction 
{
public:
	PolizFunLeq() {}
	virtual ~PolizFunLeq() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1<=i2);
	}
};

class PolizFunGeq: public PolizFunction 
{
public:
	PolizFunGeq() {}
	virtual ~PolizFunGeq() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizInt * p1 = dynamic_cast<PolizInt *>(op1);
		if(!p1)
			throw PolizNotInt(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		int i1, i2;
		i2 = p2->Get();
		i1 = p1->Get();
		delete p1;
		delete p2;
		return new PolizInt(i1>=i2);
	}
};

class PolizAssign:public PolizFunction
{
public:
	PolizAssign() {}
	virtual ~PolizAssign() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op1 = stack->Pop();
		PolizVar * p1 = dynamic_cast<PolizVar *>(op1);
		if(!p1)
			throw PolizNotVar(op1);
		PolizElem * op2 = stack->Pop();
		PolizInt * p2 = dynamic_cast<PolizInt *>(op2);
		if(!p2)
			throw PolizNotInt(op2);
		Variable * var = p1->GetVar();
		var->SetValue(p2->Get());
		delete p2;
		delete p1;
		return NULL;
	}
};

class PolizPrint:public PolizFunction
{
public:
	PolizPrint() {}
	virtual ~PolizPrint() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op;
		PolizConst * print_elem;
		op = stack->Pop();
		while(dynamic_cast<PolizArgEnd *>(op)== NULL && op!=NULL)
		{
			print_elem = dynamic_cast<PolizConst *>(op);
			if(!print_elem)
				throw PolizUnprintable(op);
			print_elem->Print();
		}
		if(!op)
			throw PolizInfPrint(op);
		return NULL;
	}
};

class PolizIndex:public PolizFunction
{
public:
	PolizIndex() {}
	virtual ~PolizIndex() {}
	virtual PolizElem * EvaluateFun(PolizStack * stack) const
	{
		PolizElem * op;
		PolizInt * index;
		PolizVar * var;
		Variable * indexed_var;
		op = stack->Pop();
		index = dynamic_cast<PolizInt *>(op)
		if(!index)
			throw PolizNotInt(op);
		op = stack->Pop();
		var = dynamic_cast<PolizVar *>(op)
		if(!var)
			throw PolizNotVar(op);
		
		return var;
	}
};

class PolizTurn:public PolizFunction
{
};

class PolizRaw:public PolizFunction
{
};

class PolizId:public PolizFunction
{
};

class PolizPlayers:public PolizFunction
{
};

class PolizActPlayers:public PolizFunction
{
};

class PolizSupply:public PolizFunction
{
};

class PolizRawPrice:public PolizFunction
{
};

class PolizDemand:public PolizFunction
{
};

class PolizProdPrice:public PolizFunction
{
};

class PolizMoney:public PolizFunction
{
};

class PolizProduction:public PolizFunction
{
};

class PolizFacts:public PolizFunction
{
};

class PolizAutoFacts:public PolizFunction
{
};

class PolizManuf:public PolizFunction
{
};

class PolizRawSold:public PolizFunction
{
};

class PolizProdBought:public PolizFunction
{
};

class PolizResRawPrice:public PolizFunction
{
};

class PolizResProdPrice:public PolizFunction
{
};



#endif


















































